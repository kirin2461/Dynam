#pragma once
// ncp_csprng.hpp — Cryptographically Secure PRNG wrapper for libsodium
// Phase 0: Replaces all std::mt19937 usage across the project
//
// Why: mt19937 is a statistical PRNG with predictable output.
// DPI/ML systems can detect patterns in padding, timing, and sizes
// generated by mt19937. libsodium's randombytes uses OS CSPRNG
// (CryptGenRandom on Windows, /dev/urandom on Linux).

#ifndef NCP_CSPRNG_HPP
#define NCP_CSPRNG_HPP

#include <sodium.h>
#include <cstdint>
#include <cstddef>
#include <vector>
#include <algorithm>
#include <stdexcept>

namespace ncp {

/// Initialize libsodium (call once at startup). Thread-safe, idempotent.
inline bool csprng_init() {
    static bool initialized = false;
    if (!initialized) {
        if (sodium_init() < 0) {
            return false;
        }
        initialized = true;
    }
    return true;
}

/// Generate a uniform random uint32_t in [0, upper_bound)
/// Drop-in replacement for std::uniform_int_distribution with mt19937
inline uint32_t csprng_uniform(uint32_t upper_bound) {
    if (upper_bound <= 1) return 0;
    return randombytes_uniform(upper_bound);
}

/// Generate a uniform random integer in [min_val, max_val] (inclusive)
/// Replaces: std::uniform_int_distribution<int>(min, max)(rng)
inline int csprng_range(int min_val, int max_val) {
    if (min_val >= max_val) return min_val;
    uint32_t range = static_cast<uint32_t>(max_val - min_val + 1);
    return min_val + static_cast<int>(randombytes_uniform(range));
}

/// Generate a uniform random size_t in [min_val, max_val] (inclusive)
inline size_t csprng_range_size(size_t min_val, size_t max_val) {
    if (min_val >= max_val) return min_val;
    uint32_t range = static_cast<uint32_t>(max_val - min_val + 1);
    return min_val + static_cast<size_t>(randombytes_uniform(range));
}

/// Generate a uniform random double in [0.0, 1.0)
/// Replaces: std::uniform_real_distribution<double>(0.0, 1.0)(rng)
inline double csprng_double() {
    uint32_t val = randombytes_random();
    return static_cast<double>(val) / (static_cast<double>(UINT32_MAX) + 1.0);
}

/// Generate a uniform random double in [min_val, max_val)
inline double csprng_double_range(double min_val, double max_val) {
    return min_val + csprng_double() * (max_val - min_val);
}

/// Fill a buffer with random bytes
/// Replaces: std::generate(buf.begin(), buf.end(), [&]{ return dist(rng); })
inline void csprng_fill(void* buf, size_t len) {
    randombytes_buf(buf, len);
}

/// Fill a vector with random bytes
inline void csprng_fill(std::vector<uint8_t>& buf) {
    randombytes_buf(buf.data(), buf.size());
}

/// Generate a random boolean with given probability of true [0.0, 1.0]
inline bool csprng_coin(double probability = 0.5) {
    return csprng_double() < probability;
}

/// Cryptographically secure shuffle (Fisher-Yates with CSPRNG)
/// Replaces: std::shuffle(begin, end, rng)
template<typename RandomIt>
void csprng_shuffle(RandomIt first, RandomIt last) {
    auto n = std::distance(first, last);
    for (auto i = n - 1; i > 0; --i) {
        auto j = static_cast<decltype(i)>(randombytes_uniform(static_cast<uint32_t>(i + 1)));
        std::iter_swap(first + i, first + j);
    }
}

/// Generate a random uint64_t
inline uint64_t csprng_uint64() {
    uint64_t val;
    randombytes_buf(&val, sizeof(val));
    return val;
}

/// Generate a random uint32_t
inline uint32_t csprng_uint32() {
    return randombytes_random();
}

/// Generate random bytes as a vector
inline std::vector<uint8_t> csprng_bytes(size_t count) {
    std::vector<uint8_t> result(count);
    randombytes_buf(result.data(), count);
    return result;
}

/// CSPRNG — OOP wrapper around the csprng_* free functions.
/// Provides CSPRNG::uniform_double(), CSPRNG::shuffle(), etc.
/// used by ncp_timing.cpp, ncp_identity.cpp and others (Phase 0.11).
struct CSPRNG {
    /// Uniform double in [min_val, max_val)
    static inline double uniform_double(double min_val, double max_val) {
        return csprng_double_range(min_val, max_val);
    }
    /// Uniform double in [0.0, 1.0)
    static inline double uniform_double() {
        return csprng_double();
    }
    /// Uniform uint32_t in [0, upper_bound)
    static inline uint32_t uniform_uint32(uint32_t upper_bound) {
        return csprng_uniform(upper_bound);
    }
    /// Uniform int in [min_val, max_val]
    static inline int uniform_int(int min_val, int max_val) {
        return csprng_range(min_val, max_val);
    }
    /// Random boolean with given probability of true
    static inline bool coin(double probability = 0.5) {
        return csprng_coin(probability);
    }
    /// Fisher-Yates shuffle of any random-access container
    template<typename Container>
    static void shuffle(Container& c) {
        csprng_shuffle(c.begin(), c.end());
    }
    /// Fill buffer with random bytes
    static inline void fill(void* buf, size_t len) {
        csprng_fill(buf, len);
    }
    /// Fill vector with random bytes
    static inline void fill(std::vector<uint8_t>& buf) {
        csprng_fill(buf);
    }
    /// Random bytes as vector
    static inline std::vector<uint8_t> bytes(size_t count) {
        return csprng_bytes(count);
    }
};

} // namespace ncp

#endif // NCP_CSPRNG_HPP
